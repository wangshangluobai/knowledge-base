# Rust

### 关于变量理解记录

从 `Javascript` 开发者的角度去理解 `Rust` 的变量规则

`Rust` 对所有权的定义规则

    1. Rust 中每个值都有一个所有者。
    2. 值在任何时刻有且仅有一个所有者。
    3. 当所有者离开作用域时，这个值将被丢弃。

`Rust` 中使用 `let` 声明的变量默认是不可变的，需要使用 `mut` 关键字来声明可变的变量。而使用 `const` 声明的常量无法使用 `mut` 关键字

`Rust` 中提到的 \`所有权\` 是指内存中存储的数据，可以被源码中哪个变量使用。`Rust` 想要掌控每一条数据，每一块内存，所以像 `Javascript` 那样随意的操作变量，`Rust` 是不允许的。
根据上方的定义规则，`Rust` 将变量的操作大致分为三种：引用(借用)、移动、切片。

1. 引用：数据的所有者不变，引用者可以通过所有者访问到数据。& 符号做标记
2. 移动：数据的所有者改变，数据的所有权会易主。move 关键字做标记
3. 切片：数据的所有者不变，会将数据从储存空间层次复制一份。



Q: 值引用的解引用后会拿到值的所有权？值引用的作用体现在什么地方？

A: 解引用值引用（如 *self）并不会获得值的所有权，而是提供了对值本身的直接访问。解引用操作让你能够查看或修改被引用的值（如果该引用是可变的），但它不改变所有权关系。也就是说，解引用后你仍然不能移动或销毁原始数据，因为所有权仍然属于引用创建的地方。

1. 资源共享：值引用允许程序的不同部分共享同一份数据，而不需要复制数据。这对于大型数据结构尤其有用，可以避免不必要的内存消耗和提高效率。

2. 函数参数传递：通过传递引用作为函数或方法的参数，可以在不转移所有权的情况下操作数据。这样，调用者和被调用者可以同时访问数据，且调用结束后数据仍然可用。

3. 不可变性和安全性：不可变引用（&）确保数据在被引用期间不会被修改，这有助于编写更安全、更容易推理的代码。

4. 迭代和遍历：在处理集合（如向量、链表等）时，通过引用遍历可以避免复制整个集合，提高效率。

5. 方法调用：在面向对象编程中，引用常用于方法调用，允许对象自身的方法操作其数据，而不必担心所有权问题。

6. 借用和生命周期管理：Rust 的借用系统通过引用管理数据的生命周期，确保没有悬垂引用，从而在编译时避免了运行时的内存错误。


Q: 为什么值引用不能直接对值进行访问？值引用是一种间接访问方式，这句话是什么意思？
如果我将一个值引用，解引用后，哪我可以修改这个解引用的值么？对解引用的值进行操作，会影响到原数据么?

A:值引用不能直接对值进行访问，这句话的意思是，当你拥有一个值的引用（比如 &T），你实际上是通过一个地址（引用）来间接访问这个值，而不是直接操作值本身。引用提供了一种间接的方式，让你能够查看或修改（如果是指向可变数据的引用）被引用的数据，而不是直接操控数据的原始存储位置。

当你对一个值引用进行解引用（使用 * 操作符），如 *reference_to_value，你确实可以获得对值本身的直接访问。解引用后，是否可以修改这个值取决于引用的类型：
- 不可变引用（&T）：解引用后，你只能读取这个值，不能修改它。尝试修改会引发编译错误，因为不可变引用保证了数据的不可变性。
- 可变引用（&mut T）：解引用后，你可以修改这个值。可变引用允许你直接改变其指向的数据。对解引用的值进行操作会直接影响到原始数据，因为它们本质上指向同一块内存。

总结来说，解引用一个值引用确实允许你直接操作数据，但这是否会导致原数据的变化，取决于引用的类型。不可变引用确保数据的只读性，而可变引用则允许修改数据，这些操作都会直接影响到原数据（在可变引用的情况下）。

Q: 至于值引用不能直接被 match 语句匹配的问题，这是因为 match 需要确切知道它正在匹配的具体类型，而引用是一种间接访问方式。通过解引用，可以将引用转换为直接匹配的值类型，从而让 match 能够识别出枚举的各个变体。
这段话中提到解引用是中间接访问方式，通过解引用可以将引用转换为直接匹配的值类型，为什么间接引用的访问方式无法直接匹配？

A: 在这段话中，“间接访问方式”指的是通过引用（&T）访问数据的方式，而不是直接操作数据本身。在 Rust 中，match 语句需要知道它正在匹配的确切类型，以便正确地执行代码路径。而引用（&T）提供的是对值的间接访问，它不是值本身，因此 match 无法直接与枚举的变体进行比较，因为引用不等同于枚举的实例。

解引用（*）操作将引用转换为它所指向的值，这样 match 就可以比较解引用后得到的值（即 T 类型的实例）与枚举的各个变体。解引用是将引用转换为值的过程，这样 match 就可以像处理值本身那样进行精确匹配。在解引用之后，match 可以识别出 Cons 或 Nil 等枚举变体，因为现在它面对的是 List 类型的实例，而不是引用。

总结来说，间接引用（&T）不能直接用于 match 是因为 match 需要匹配的是值，而不是指向值的指针。解引用（*）允许我们将引用转换为值，从而使 match 能够识别并匹配枚举的各个实例。

Q: 间接引用的值是指针？间接引用不是可以访问值么？为什么可以访问值，却不能将访问的值作用于match比较?

A: 是的，我的表述可能造成了混淆。在 Rust 中，当提到“间接引用”，我们通常指的是通过引用（&T 或 &mut T）来访问数据，而不是传统意义上的指针操作。引用可以让你安全地访问数据，而无需直接操控内存地址。这一点上，引用确实提供了访问值的能力。

关于为何间接引用不能直接用于 match 的比较，核心在于匹配表达式的预期类型和引用类型之间的不匹配。match 期望直接匹配具体的枚举变体或其他值类型，而引用（即使是可解引用为那些类型的引用）在没有解引用前，其类型是不同的——它是一个引用类型，而不是 match 直接期待的枚举类型或其他具体类型。

具体来说，当你写一个 match 表达式时，每个分支都对应着某种具体的数据结构或值，比如枚举的一个变体。如果直接使用引用（如 &SomeType）进行匹配，编译器会试图将这个引用类型与枚举变体或其他值类型进行比较，这是类型系统不允许的，因为它们类型不一致。

解引用之后，你得到的是引用所指向的实际值，这时类型与枚举变体或其他待匹配的值类型匹配，因此可以成功进行比较。简而言之，不是不能访问值，而是访问的值（通过引用）在类型层面上不满足 match 直接比较的需求，需要解引用来消除这一层间接性，使其符合 match 语句的类型要求。

Q: ref 和 & 的区别是什么

A: 在 Rust 中，ref 关键字和 & 运算符都可以用于创建引用，但它们在上下文中的用法有所不同：

1. ref in match patterns:
  - ref 是在 match 表达式中使用的，它允许你在匹配模式时创建一个引用绑定到匹配到的值。例如：
  ```rust
  match some_value {
    Some(ref value) => println!("Value is {}", value),
    None => println!("No value"),
  }
  ```
  - 在这个例子中，ref value 会创建一个不可变引用到 Some 枚举变体中的值，而不是复制这个值。
2. & as an address-of operator:
  - & 通常用作地址运算符，它会创建一个引用到其右侧的值。这可以用于函数参数、局部变量等：
  ```rust
  fn print_length(s: &str) {
    println!("Length of the string is: {}", s.len());
  }

  let my_string = "Hello";
  print_length(&my_string);
  ```
  - 在这里，&my_string 创建了一个不可变引用，传递给 print_length 函数，而不是字符串本身。

3. 关于 & 和 ref
- & 用于获取变量的引用，通常在函数参数、赋值或表达式中使用。
- ref 用于在模式匹配（如 match 和 let）中绑定到值的引用，而不是值的拷贝。
- 虽然 ref 主要在模式匹配上下文中使用，但它也可以在其他需要绑定引用的地方（如特定的 let 语句）找到应用。

总结起来，ref 专门用于 match 表达式中的模式匹配，而 & 更通用，可以用于任何需要创建引用的场合。两者都能创建不可变引用，但 ref 的作用更具有针对性，仅限于模式匹配。在其他上下文中，如函数参数或表达式中，我们通常使用 &。


Q: Rust 在那些情况下会自动解引用，请提出例子来解释

A: Rust 会在以下几种常见情况下自动解引用（Deref）：

1. 方法调用： 当调用一个方法时，Rust 会尝试对方法接收者进行解引用，直到找到一个实现了该方法的类型。例如，如果你有一个指向结构体的引用，并且该结构体实现了 Display trait，你可以直接调用 println!("{}", ref_to_struct);，Rust 会自动解引用 ref_to_struct 以调用 Display trait 的 fmt::display 方法。

2. 成员访问： 类似地，当你访问结构体的成员时，Rust 也会尝试自动解引用。例如：
  ```rust
  struct MyStruct { field: i32 }
  let ref_to_struct = MyStruct { field: 42 };
  println!("Field: {}", ref_to_struct.field); // 自动解引用以访问 field
  ```
3. 操作符： 某些操作符，如 .，[] 和 +，在处理引用或智能指针时，也会自动解引用。例如：
  ```rust
  let vec = Vec::new();
  vec.push(1); // 自动解引用 vec 以调用 push 方法
  println!("{}", vec[0]); // 自动解引用 vec 以访问元素
  ```
4. 模式匹配： 在 match 表达式中，如果匹配的模式是结构体或枚举的字段，Rust 会尝试自动解引用。但是，如果 match 的主体需要引用，你需要使用 ref 关键字。例如：
  ```rust
  enum Option<T> { Some(T), None }
  let opt = Option::Some(10);
  match opt {
    Option::Some(value) => println!("Value: {}", value), // 自动解引用以访问 value
    Option::None => println!("No value"),
  }
  ```
5. 类型转换： 当进行类型转换，如 as 关键字或 From/Into 特性的使用时，Rust 也可能自动解引用。例如：
  ```rust
  let num_ref: &i32 = &5;
  let num: i32 = num_ref as i32; // 自动解引用 num_ref
  ```
请注意，这些自动解引用是有限度的，只会在类型系统允许的情况下进行，以避免类型不匹配或未定义的行为。如果需要多次解引用，或者在 match 中创建引用，通常需要显式地使用 * 操作符。
